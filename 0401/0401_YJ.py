def palindrome(data) :
    n = len(data)

    Table = [[0] * n for _ in range(n)]
   
    for i in range(n-2, -1, -1):
        for j in range(i+1, n):
            if data[i] == data[j]:
                Table[i][j] = Table[i+1][j-1]
            else:
                Table[i][j] = min(Table[i+1][j], Table[i][j-1]) + 1

    return Table[0][n-1]

def main():
    s = input()

    print(palindrome(s))


if __name__ == "__main__":
    main()






#     구하는 방식: 동적계획법에 따라 작게 작게 팰린드롬인지 판별해 가면서 팰린드롬을 구하기 
#     배열 안에 숫자들 : 제거해야 하는 문자 개수
#   1.
#   i\j a. b. c. f. b. a
#    a [0, 0, 0, 0, 0, 0]
#    b [0, 0, 0, 0, 0, 0]
#    c [0, 0, 0, 0, 0, 0]
#    f [0, 0, 0, 0, 0, 0] abcfba에서 우선 끝쪽의 b(i=4)랑 a(j=5)를 먼저 비교
#    b [0, 0, 0, 0, 0, 1]  => else) 둘이 다르면(팰린드롬이 아니란 뜻) Table[i][j]에 +1 
#    a [0, 0, 0, 0, 0, 0]         

#   2.f(i=3),b(j=4)비교도 위와 같이 진행  

#   3. 
#   i\j a. b. c. f. b. a
#    a [0, 0, 0, 0, 0, 0]
#    b [0, 0, 0, 0, 0, 0]
#    c [0, 0, 0, 0, 0, 0]
#    f [0, 0, 0, 0, 1, 2]  Next! f(i=3) ~ a(j=5)비교
#    b [0, 0, 0, 0, 0, 1]  => else)  [f(i=3),b(j=4)] & [b(i=4),a(j=5)] 중에 최솟값+1 (제거하는 개수가 최소가
#    a [0, 0, 0, 0, 0, 0]             되길 원하니깐)

#   4. 그렇게 쭉~~구하기 ㅋ

#   5.처음으로 만난 True가 된 if문 (b(i=1) == b(j=4))
#   i\j a. b. c. f. b. a
#    a [0, 0, 0, 0, 0, 0]
#    b [0, 0, 1, 2, 1, 0]
#    c [0, 0, 0, 1, 2, 3]
#    f [0, 0, 0, 0, 1, 2]  b(i=1) ~ b(j=4) 비교
#    b [0, 0, 0, 0, 0, 1]  => if) [c(i=2),f(j=3)] 값을 그대로 갖고오기 (b,b가 같은 값이니까 추가로
#    a [0, 0, 0, 0, 0, 0]          제거할 것이 없어 그 안에 값들(이전에 구한 값)의 숫자만 갖고오면 됨)   

#   6, 다시 쭈욱 구하기 ㅋ

#   7.마지막 전체 문자열 팰린드롬인지 확인
#   i\j a. b. c. f. b. a
#    a [0, 1, 2, 3, 2, 1]
#    b [0, 0, 1, 2, 1, 2]
#    c [0, 0, 0, 1, 2, 3]
#    f [0, 0, 0, 0, 1, 2]  a(i=0) ~ a(j=5) 비교
#    b [0, 0, 0, 0, 0, 1]  => if) [b(i=1),b(j=4)] 값을 그대로 갖고오기 
#    a [0, 0, 0, 0, 0, 0]          

#    재훈님이 잘 설명해주셔서 기본적인 내용은 알고 있다고 생각하고 추가적으로 제 코드에 관한 것들 위주로만 설명했습니당 
#    혹시 이해 안가는 거 있으시면 언제든 말씀해주세요 ~~